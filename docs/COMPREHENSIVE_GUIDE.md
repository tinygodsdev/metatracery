# Полное руководство по Tracery

## Содержание
1. [Введение](#введение)
2. [Быстрый старт](#быстрый-старт)
3. [Архитектура библиотеки](#архитектура-библиотеки)
4. [Синтаксис грамматики](#синтаксис-грамматики)
5. [API Reference](#api-reference)
6. [Продвинутые техники](#продвинутые-техники)
7. [Лучшие практики](#лучшие-практики)
8. [Устранение неполадок](#устранение-неполадок)
9. [Расширение библиотеки](#расширение-библиотеки)
10. [Производительность](#производительность)

## Введение

Tracery - это мощная библиотека для создания генеративных грамматик, разработанная Kate Compton. Она позволяет создавать процедурно генерируемый контент на основе правил и символов, поддерживая сложные грамматические конструкции, модификаторы, действия и различные стратегии выбора правил.

### Основные возможности:
- **Символы и правила** - базовые строительные блоки грамматики
- **Модификаторы** - преобразование текста (заглавные буквы, множественное число, артикли)
- **Действия** - динамическое управление правилами (push/pop)
- **Рекурсия** - поддержка самоссылающихся структур
- **Стратегии выбора** - различные алгоритмы выбора правил
- **Обработка ошибок** - надежная система обработки ошибок
- **Детерминизм** - возможность создания воспроизводимых результатов

## Быстрый старт

### Установка
```bash
npm install tracery-grammar
```

### Базовый пример
```javascript
var tracery = require('tracery-grammar');

// Создаем грамматику
var grammar = tracery.createGrammar({
  'animal': ['cat', 'dog', 'bird'],
  'emotion': ['happy', 'sad', 'angry'],
  'origin': ['The #emotion# #animal# runs fast.']
});

// Добавляем модификаторы
grammar.addModifiers(tracery.baseEngModifiers);

// Генерируем текст
console.log(grammar.flatten('#origin#'));
// Возможные результаты:
// "The happy cat runs fast."
// "The sad dog runs fast."
// "The angry bird runs fast."
```

## Архитектура библиотеки

### Основные компоненты

#### 1. Tracery (главный объект)
- Содержит все основные функции и классы
- Управляет глобальными настройками (генератор случайных чисел)
- Предоставляет фабричные методы для создания объектов

#### 2. Grammar (Грамматика)
- Центральный класс для работы с грамматиками
- Содержит символы и их правила
- Управляет процессом развертывания
- Поддерживает модификаторы и подграмматики

#### 3. Symbol (Символ)
- Представляет символ в грамматике
- Содержит стек правил (RuleSet)
- Управляет выбором правил
- Поддерживает динамическое добавление/удаление правил

#### 4. RuleSet (Набор правил)
- Содержит правила для символа
- Реализует стратегии выбора правил
- Поддерживает условные и иерархические правила

#### 5. TraceryNode (Узел)
- Представляет узел в дереве развертывания
- Содержит логику развертывания
- Управляет дочерними узлами
- Обрабатывает ошибки

#### 6. NodeAction (Действие узла)
- Представляет действие, выполняемое при развертывании
- Поддерживает push, pop и function действия
- Создает действия отмены

### Поток выполнения

1. **Парсинг** - правило разбивается на секции
2. **Создание узлов** - для каждой секции создается узел
3. **Развертывание** - узлы развертываются рекурсивно
4. **Применение модификаторов** - к результатам применяются модификаторы
5. **Выполнение действий** - выполняются post-действия
6. **Сборка результата** - финальный текст собирается из узлов

## Синтаксис грамматики

### Базовые конструкции

#### Символы
```javascript
{
  "symbolName": ["rule1", "rule2", "rule3"]
}
```

#### Ссылки на символы
```javascript
{
  "origin": ["#symbolName#"]
}
```

#### Текстовые секции
```javascript
{
  "origin": ["Text with #symbol# in the middle"]
}
```

### Теги и модификаторы

#### Базовый тег
```javascript
"#symbol#"
```

#### Тег с модификаторами
```javascript
"#symbol.modifier1.modifier2#"
```

#### Модификаторы с параметрами
```javascript
"#symbol.modifier(param1,param2)#"
```

### Действия

#### Push действие
```javascript
"[target:rule]#symbol#"
```

#### Pop действие
```javascript
"[target:POP]"
```

#### Множественные действия
```javascript
"[target1:rule1][target2:rule2]#symbol#"
```

### Escape-символы
```javascript
"Text with \\#literal\\# symbols"
```

## API Reference

### Tracery

#### `tracery.createGrammar(raw)`
Создает новую грамматику из сырого объекта.

**Параметры:**
- `raw` (Object) - объект с символами и правилами

**Возвращает:** Grammar

**Пример:**
```javascript
var grammar = tracery.createGrammar({
  'animal': ['cat', 'dog'],
  'origin': ['#animal# is cute']
});
```

#### `tracery.parse(rule)`
Парсит правило в секции.

**Параметры:**
- `rule` (String) - правило для парсинга

**Возвращает:** Array секций с ошибками

**Пример:**
```javascript
var sections = tracery.parse('Text #symbol# more text');
// Возвращает массив секций с типами и содержимым
```

#### `tracery.parseTag(tagContents)`
Парсит содержимое тега.

**Параметры:**
- `tagContents` (String) - содержимое тега

**Возвращает:** Object с символом, модификаторами и действиями

#### `tracery.setRng(newRng)`
Устанавливает генератор случайных чисел.

**Параметры:**
- `newRng` (Function) - функция, возвращающая случайное число [0,1)

**Пример:**
```javascript
tracery.setRng(function() { return 0.5; }); // Детерминистический
```

### Grammar

#### `new Grammar(raw, settings)`
Создает новую грамматику.

#### `grammar.addModifiers(mods)`
Добавляет модификаторы к грамматике.

**Параметры:**
- `mods` (Object) - объект с модификаторами

**Пример:**
```javascript
grammar.addModifiers(tracery.baseEngModifiers);
```

#### `grammar.clearState()`
Очищает состояние всех символов.

#### `grammar.expand(rule, allowEscapeChars)`
Разворачивает правило и возвращает узел.

**Параметры:**
- `rule` (String) - правило для развертывания
- `allowEscapeChars` (Boolean) - разрешить escape-символы

**Возвращает:** TraceryNode

#### `grammar.flatten(rule, allowEscapeChars)`
Разворачивает правило и возвращает финальный текст.

**Параметры:**
- `rule` (String) - правило для развертывания
- `allowEscapeChars` (Boolean) - разрешить escape-символы

**Возвращает:** String

#### `grammar.pushRules(key, rawRules, sourceAction)`
Добавляет правила к символу.

**Параметры:**
- `key` (String) - имя символа
- `rawRules` (Array|String) - правила для добавления
- `sourceAction` (NodeAction) - действие-источник

#### `grammar.popRules(key)`
Удаляет последние добавленные правила символа.

**Параметры:**
- `key` (String) - имя символа

#### `grammar.selectRule(key, node, errors)`
Выбирает правило для символа.

**Параметры:**
- `key` (String) - имя символа
- `node` (TraceryNode) - узел, запрашивающий правило
- `errors` (Array) - массив для ошибок

**Возвращает:** String

### Symbol

#### `new Symbol(grammar, key, rawRules)`
Создает новый символ.

#### `symbol.clearState()`
Очищает состояние символа.

#### `symbol.pushRules(rawRules)`
Добавляет новые правила в стек.

#### `symbol.popRules()`
Удаляет последние правила из стека.

#### `symbol.selectRule(node, errors)`
Выбирает правило для использования.

#### `symbol.getActiveRules()`
Возвращает активные правила.

### TraceryNode

#### `new TraceryNode(parent, childIndex, settings)`
Создает новый узел.

#### `node.expand(preventRecursion)`
Разворачивает узел.

#### `node.expandChildren(childRule, preventRecursion)`
Разворачивает дочерние узлы.

#### `node.clearEscapeChars()`
Очищает escape-символы из финального текста.

### NodeAction

#### `new NodeAction(node, raw)`
Создает новое действие.

#### `action.createUndo()`
Создает действие отмены.

#### `action.activate()`
Активирует действие.

#### `action.toText()`
Возвращает текстовое представление действия.

## Продвинутые техники

### Создание пользовательских модификаторов

```javascript
var customModifiers = {
  'shout': function(s) {
    return s.toUpperCase() + '!';
  },
  'whisper': function(s) {
    return s.toLowerCase() + '...';
  },
  'repeat': function(s, params) {
    var count = parseInt(params[0]) || 2;
    return s.repeat(count);
  }
};

grammar.addModifiers(customModifiers);
```

### Детерминистическая генерация

```javascript
// Seeded random number generator
function seededRandom(seed) {
  return function() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };
}

tracery.setRng(seededRandom(12345));
```

### Динамическое управление правилами

```javascript
var grammar = tracery.createGrammar({
  'origin': ['[mood:happy]#story#'],
  'story': ['The character is #mood#.'],
  'mood': ['happy', 'sad']
});

// Динамически добавляем новые правила
grammar.pushRules('mood', ['excited', 'angry']);
```

### Обработка ошибок

```javascript
var grammar = tracery.createGrammar({
  'origin': ['#existingSymbol# #missingSymbol#']
});

var node = grammar.expand('#origin#');
if (node.errors.length > 0) {
  console.log('Errors:', node.errors);
}
```

### Создание подграмматик

```javascript
var mainGrammar = tracery.createGrammar({
  'origin': ['#greeting#']
});

var subGrammar = tracery.createGrammar({
  'greeting': ['Hello from subgrammar!']
});

mainGrammar.subgrammars.push(subGrammar);
```

## Лучшие практики

### Организация грамматики

1. **Группировка символов** - группируйте связанные символы
2. **Понятные имена** - используйте описательные имена символов
3. **Модульность** - разделяйте большие грамматики на модули
4. **Документация** - комментируйте сложные структуры

### Производительность

1. **Ограничение рекурсии** - избегайте слишком глубокой рекурсии
2. **Очистка стека** - используйте POP действия для очистки
3. **Кэширование** - кэшируйте часто используемые результаты
4. **Оптимизация правил** - ограничивайте количество правил в символах

### Читаемость

1. **Отступы** - используйте отступы в JSON
2. **Комментарии** - добавляйте комментарии к сложным структурам
3. **Консистентность** - следуйте единому стилю именования
4. **Тестирование** - создавайте тесты для грамматик

### Безопасность

1. **Валидация входных данных** - проверяйте входные данные
2. **Ограничение глубины** - устанавливайте лимиты на глубину рекурсии
3. **Обработка ошибок** - всегда обрабатывайте ошибки
4. **Санитизация** - очищайте пользовательский ввод

## Устранение неполадок

### Частые проблемы

#### 1. Незакрытые теги
```
Ошибка: "Unclosed tag"
Решение: Проверьте, что все теги закрыты символами #
```

#### 2. Несбалансированные скобки
```
Ошибка: "Too many [" или "Too many ]"
Решение: Проверьте баланс скобок в действиях
```

#### 3. Отсутствующие символы
```
Результат: "((missingSymbol))"
Решение: Убедитесь, что символ определен в грамматике
```

#### 4. Бесконечная рекурсия
```
Проблема: Зависание при генерации
Решение: Добавьте условия выхода из рекурсии
```

### Отладка

#### Включение отладочной информации
```javascript
var node = grammar.expand('#origin#');
console.log('Errors:', node.errors);
console.log('Node tree:', node);
```

#### Проверка состояния символов
```javascript
var symbol = grammar.symbols['symbolName'];
console.log('Active rules:', symbol.getActiveRules());
console.log('Stack depth:', symbol.stack.length);
```

#### Трассировка выполнения
```javascript
// Добавьте console.log в код библиотеки для трассировки
```

## Расширение библиотеки

### Создание новых типов действий

```javascript
// Расширение NodeAction для новых типов действий
NodeAction.prototype.activate = function() {
  switch (this.type) {
    case 3: // Новый тип действия
      // Ваша логика
      break;
    default:
      // Стандартная логика
  }
};
```

### Добавление новых стратегий выбора

```javascript
// Расширение RuleSet для новых стратегий
RuleSet.prototype.selectRule = function(errors) {
  switch (this.distribution) {
    case "custom":
      // Ваша стратегия выбора
      break;
    default:
      // Стандартная логика
  }
};
```

### Создание плагинов

```javascript
function TraceryPlugin(grammar) {
  this.grammar = grammar;
  this.init();
}

TraceryPlugin.prototype.init = function() {
  // Инициализация плагина
};

TraceryPlugin.prototype.addFeature = function() {
  // Добавление новой функциональности
};
```

## Производительность

### Оптимизация

1. **Кэширование узлов** - кэшируйте результаты развертывания
2. **Ленивая загрузка** - загружайте правила по требованию
3. **Пулинг объектов** - переиспользуйте объекты узлов
4. **Оптимизация парсинга** - оптимизируйте регулярные выражения

### Профилирование

```javascript
// Измерение времени выполнения
var start = Date.now();
var result = grammar.flatten('#origin#');
var end = Date.now();
console.log('Generation time:', end - start, 'ms');
```

### Мониторинг памяти

```javascript
// Проверка использования памяти
if (process.memoryUsage) {
  console.log('Memory usage:', process.memoryUsage());
}
```

### Масштабирование

1. **Разделение грамматик** - разделяйте большие грамматики
2. **Асинхронная генерация** - используйте асинхронные методы
3. **Кэширование результатов** - кэшируйте часто используемые результаты
4. **Оптимизация алгоритмов** - оптимизируйте алгоритмы выбора правил

## Заключение

Tracery предоставляет мощный и гибкий инструментарий для создания генеративных грамматик. Понимание архитектуры, API и лучших практик позволит вам создавать сложные и эффективные системы процедурной генерации контента.

### Ключевые моменты:
- Используйте модульный подход к организации грамматик
- Применяйте модификаторы для гибкого преобразования текста
- Используйте действия для динамического управления правилами
- Обрабатывайте ошибки и ограничивайте рекурсию
- Оптимизируйте производительность для больших грамматик
- Расширяйте библиотеку для специфических нужд

### Дополнительные ресурсы:
- [Официальный репозиторий Tracery](https://github.com/galaxykate/tracery/)
- [Документация Kate Compton](http://www.galaxykate.com/tracery/)
- [Примеры использования](https://github.com/galaxykate/tracery/tree/master/examples)
